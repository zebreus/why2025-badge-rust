/* automatically generated by rust-bindgen 0.72.0 */

#[derive(PartialEq, Copy, Clone, Hash, Debug, Default)]
#[repr(C)]
pub struct __BindgenComplex<T> {
    pub re: T,
    pub im: T,
}
#[derive(PartialEq, Copy, Clone, Hash, Debug, Default)]
#[repr(transparent)]
pub struct __BindgenFloat16(pub u16);
pub type __uint8_t = ::core::ffi::c_uchar;
pub type __uint16_t = ::core::ffi::c_ushort;
pub type __int32_t = ::core::ffi::c_int;
pub type __uint32_t = ::core::ffi::c_uint;
pub type __int_least64_t = ::core::ffi::c_longlong;
pub type __intmax_t = ::core::ffi::c_longlong;
pub type __uintmax_t = ::core::ffi::c_ulonglong;
pub type locale_t = ::core::ffi::c_int;
pub type size_t = ::core::ffi::c_uint;
pub type wchar_t = ::core::ffi::c_int;
pub type fenv_t = size_t;
pub type fexcept_t = size_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct option {
    pub name: *const ::core::ffi::c_char,
    pub has_arg: ::core::ffi::c_int,
    pub flag: *mut ::core::ffi::c_int,
    pub val: ::core::ffi::c_int,
}
pub type wint_t = ::core::ffi::c_uint;
pub type __blkcnt_t = ::core::ffi::c_long;
pub type __blksize_t = ::core::ffi::c_long;
pub type _off_t = ::core::ffi::c_long;
pub type __pid_t = ::core::ffi::c_int;
pub type __dev_t = ::core::ffi::c_short;
pub type __uid_t = ::core::ffi::c_ushort;
pub type __gid_t = ::core::ffi::c_ushort;
pub type __ino_t = ::core::ffi::c_ushort;
pub type __mode_t = __uint32_t;
pub type __off_t = _off_t;
pub type _fpos_t = ::core::ffi::c_long;
pub type _ssize_t = ::core::ffi::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _mbstate_t {
    pub __count: ::core::ffi::c_int,
    pub __value: _mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _mbstate_t__bindgen_ty_1 {
    pub __wch: wint_t,
    pub __wchb: [::core::ffi::c_uchar; 4usize],
    pub __ucs: __uint32_t,
    pub __ucs2: __uint16_t,
}
impl ::core::fmt::Debug for _mbstate_t__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "_mbstate_t__bindgen_ty_1 {{ union }}")
    }
}
impl ::core::fmt::Debug for _mbstate_t {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "_mbstate_t {{ __count: {:?}, __value: {:?} }}",
            self.__count, self.__value
        )
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __iconv_t {
    _unused: [u8; 0],
}
pub type _iconv_t = *mut __iconv_t;
pub type __clockid_t = ::core::ffi::c_ulong;
pub type __nl_item = __int32_t;
pub type __nlink_t = ::core::ffi::c_ushort;
pub type __suseconds_t = ::core::ffi::c_long;
pub type __useconds_t = ::core::ffi::c_ulong;
pub type iconv_t = _iconv_t;
pub type fp_rnd = ::core::ffi::c_int;
pub type fp_except = ::core::ffi::c_int;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct imaxdiv_t {
    pub quot: intmax_t,
    pub rem: intmax_t,
}
pub type _wchar_t = ::core::ffi::c_int;
pub type nl_item = __nl_item;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lconv {
    pub decimal_point: *mut ::core::ffi::c_char,
    pub thousands_sep: *mut ::core::ffi::c_char,
    pub grouping: *mut ::core::ffi::c_char,
    pub int_curr_symbol: *mut ::core::ffi::c_char,
    pub currency_symbol: *mut ::core::ffi::c_char,
    pub mon_decimal_point: *mut ::core::ffi::c_char,
    pub mon_thousands_sep: *mut ::core::ffi::c_char,
    pub mon_grouping: *mut ::core::ffi::c_char,
    pub positive_sign: *mut ::core::ffi::c_char,
    pub negative_sign: *mut ::core::ffi::c_char,
    pub int_frac_digits: ::core::ffi::c_char,
    pub frac_digits: ::core::ffi::c_char,
    pub p_cs_precedes: ::core::ffi::c_char,
    pub p_sep_by_space: ::core::ffi::c_char,
    pub n_cs_precedes: ::core::ffi::c_char,
    pub n_sep_by_space: ::core::ffi::c_char,
    pub p_sign_posn: ::core::ffi::c_char,
    pub n_sign_posn: ::core::ffi::c_char,
    pub int_n_cs_precedes: ::core::ffi::c_char,
    pub int_n_sep_by_space: ::core::ffi::c_char,
    pub int_n_sign_posn: ::core::ffi::c_char,
    pub int_p_cs_precedes: ::core::ffi::c_char,
    pub int_p_sep_by_space: ::core::ffi::c_char,
    pub int_p_sign_posn: ::core::ffi::c_char,
    pub __bindgen_padding_0: [u8; 2usize],
}
pub type regoff_t = isize;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct regex_t {
    pub re_magic: ::core::ffi::c_uint,
    pub re_nsub: size_t,
    pub re_endp: *const ::core::ffi::c_char,
    pub re_g: *mut re_guts,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct regmatch_t {
    pub rm_so: regoff_t,
    pub rm_eo: regoff_t,
}
pub type in_addr_t = __uint32_t;
pub type blkcnt_t = __blkcnt_t;
pub type blksize_t = __blksize_t;
pub type clock_t = ::core::ffi::c_ulong;
pub type time_t = __int_least64_t;
pub type ino_t = __ino_t;
pub type ssize_t = _ssize_t;
pub type off_t = __off_t;
pub type dev_t = __dev_t;
pub type uid_t = __uid_t;
pub type gid_t = __gid_t;
pub type pid_t = __pid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type clockid_t = __clockid_t;
pub type useconds_t = __useconds_t;
pub type suseconds_t = __suseconds_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum VISIT {
    preorder = 0,
    postorder = 1,
    endorder = 2,
    leaf = 3,
}
pub type __compar_fn_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::core::ffi::c_void,
        arg2: *const ::core::ffi::c_void,
    ) -> ::core::ffi::c_int,
>;
pub type __gnuc_va_list = __builtin_va_list;
pub type __ungetc_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __file {
    pub unget: __ungetc_t,
    pub flags: __uint8_t,
    pub __bindgen_padding_0: [u8; 3usize],
    pub put: ::core::option::Option<
        unsafe extern "C" fn(arg1: ::core::ffi::c_char, arg2: *mut __file) -> ::core::ffi::c_int,
    >,
    pub get: ::core::option::Option<unsafe extern "C" fn(arg1: *mut __file) -> ::core::ffi::c_int>,
    pub flush:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut __file) -> ::core::ffi::c_int>,
}
pub type __FILE = __file;
pub type FILE = __FILE;
pub type fpos_t = _fpos_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::core::ffi::c_int,
    pub rem: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::core::ffi::c_long,
    pub rem: ::core::ffi::c_long,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::core::ffi::c_longlong,
    pub rem: ::core::ffi::c_longlong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: time_t,
    pub tv_usec: suseconds_t,
    pub __bindgen_padding_0: [u8; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: time_t,
    pub tv_nsec: ::core::ffi::c_long,
    pub __bindgen_padding_0: [u8; 4usize],
}
pub type __fd_mask = ::core::ffi::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tms {
    pub tms_utime: clock_t,
    pub tms_stime: clock_t,
    pub tms_cutime: clock_t,
    pub tms_cstime: clock_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::core::ffi::c_int,
    pub tm_min: ::core::ffi::c_int,
    pub tm_hour: ::core::ffi::c_int,
    pub tm_mday: ::core::ffi::c_int,
    pub tm_mon: ::core::ffi::c_int,
    pub tm_year: ::core::ffi::c_int,
    pub tm_wday: ::core::ffi::c_int,
    pub tm_yday: ::core::ffi::c_int,
    pub tm_isdst: ::core::ffi::c_int,
}
pub type wctype_t = ::core::ffi::c_int;
pub type mbstate_t = _mbstate_t;
pub type wctrans_t = ::core::ffi::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct path_t {
    pub buffer: *mut ::core::ffi::c_char,
    pub device: *mut ::core::ffi::c_char,
    pub directory: *mut ::core::ffi::c_char,
    pub filename: *mut ::core::ffi::c_char,
    pub unixpath: *mut ::core::ffi::c_char,
    pub len: size_t,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum path_parse_result_t {
    PATH_PARSE_OK = 0,
    PATH_PARSE_EMPTY_DEVICE = -1,
    PATH_PARSE_NO_DEVICE = -2,
    PATH_PARSE_UNCLOSED_DIRECTORY = -3,
    PATH_PARSE_INVALID_DEVICE_CHAR = -4,
    PATH_PARSE_INVALID_DIR_CHAR = -5,
    PATH_PARSE_INVALID_FILE_CHAR = -6,
    PATH_PARSE_EMPTY_PATH = -7,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum application_source_t {
    APPLICATION_SOURCE_UNKNOWN = 0,
    APPLICATION_SOURCE_BADGEHUB = 1,
    APPLICATION_SOURCE_MAX = 2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct application_t {
    pub unique_identifier: *const ::core::ffi::c_char,
    pub name: *const ::core::ffi::c_char,
    pub author: *const ::core::ffi::c_char,
    pub version: *const ::core::ffi::c_char,
    pub interpreter: *const ::core::ffi::c_char,
    pub metadata_file: *const ::core::ffi::c_char,
    pub installed_path: *const ::core::ffi::c_char,
    pub binary_path: *const ::core::ffi::c_char,
    pub source: application_source_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct application_list {
    _unused: [u8; 0],
}
pub type application_list_handle = *mut application_list;
pub type key_code_t = u32;
pub type key_mod_t = u16;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum keyboard_scancode_t {
    KEY_SCANCODE_UNKNOWN = 0,
    KEY_SCANCODE_A = 4,
    KEY_SCANCODE_B = 5,
    KEY_SCANCODE_C = 6,
    KEY_SCANCODE_D = 7,
    KEY_SCANCODE_E = 8,
    KEY_SCANCODE_F = 9,
    KEY_SCANCODE_G = 10,
    KEY_SCANCODE_H = 11,
    KEY_SCANCODE_I = 12,
    KEY_SCANCODE_J = 13,
    KEY_SCANCODE_K = 14,
    KEY_SCANCODE_L = 15,
    KEY_SCANCODE_M = 16,
    KEY_SCANCODE_N = 17,
    KEY_SCANCODE_O = 18,
    KEY_SCANCODE_P = 19,
    KEY_SCANCODE_Q = 20,
    KEY_SCANCODE_R = 21,
    KEY_SCANCODE_S = 22,
    KEY_SCANCODE_T = 23,
    KEY_SCANCODE_U = 24,
    KEY_SCANCODE_V = 25,
    KEY_SCANCODE_W = 26,
    KEY_SCANCODE_X = 27,
    KEY_SCANCODE_Y = 28,
    KEY_SCANCODE_Z = 29,
    KEY_SCANCODE_1 = 30,
    KEY_SCANCODE_2 = 31,
    KEY_SCANCODE_3 = 32,
    KEY_SCANCODE_4 = 33,
    KEY_SCANCODE_5 = 34,
    KEY_SCANCODE_6 = 35,
    KEY_SCANCODE_7 = 36,
    KEY_SCANCODE_8 = 37,
    KEY_SCANCODE_9 = 38,
    KEY_SCANCODE_0 = 39,
    KEY_SCANCODE_RETURN = 40,
    KEY_SCANCODE_ESCAPE = 41,
    KEY_SCANCODE_BACKSPACE = 42,
    KEY_SCANCODE_TAB = 43,
    KEY_SCANCODE_SPACE = 44,
    KEY_SCANCODE_MINUS = 45,
    KEY_SCANCODE_EQUALS = 46,
    KEY_SCANCODE_LEFTBRACKET = 47,
    KEY_SCANCODE_RIGHTBRACKET = 48,
    #[doc = "< Located at the lower left of the return\n   key on ISO keyboards and at the right end\n   of the QWERTY row on ANSI keyboards.\n   Produces REVERSE SOLIDUS (backslash) and\n   VERTICAL LINE in a US layout, REVERSE\n   SOLIDUS and VERTICAL LINE in a UK Mac\n   layout, NUMBER SIGN and TILDE in a UK\n   Windows layout, DOLLAR SIGN and POUND SIGN\n   in a Swiss German layout, NUMBER SIGN and\n   APOSTROPHE in a German layout, GRAVE\n   ACCENT and POUND SIGN in a French Mac\n   layout, and ASTERISK and MICRO SIGN in a\n   French Windows layout."]
    KEY_SCANCODE_BACKSLASH = 49,
    #[doc = "< ISO USB keyboards actually use this code\n   instead of 49 for the same key, but all\n   OSes I've seen treat the two codes\n   identically. So, as an implementor, unless\n   your keyboard generates both of those\n   codes and your OS treats them differently,\n   you should generate KEY_SCANCODE_BACKSLASH\n   instead of this code. As a user, you\n   should not rely on this code because SDL\n   will never generate it with most (all?)\n   keyboards."]
    KEY_SCANCODE_NONUSHASH = 50,
    KEY_SCANCODE_SEMICOLON = 51,
    KEY_SCANCODE_APOSTROPHE = 52,
    #[doc = "< Located in the top left corner (on both ANSI\n   and ISO keyboards). Produces GRAVE ACCENT and\n   TILDE in a US Windows layout and in US and UK\n   Mac layouts on ANSI keyboards, GRAVE ACCENT\n   and NOT SIGN in a UK Windows layout, SECTION\n   SIGN and PLUS-MINUS SIGN in US and UK Mac\n   layouts on ISO keyboards, SECTION SIGN and\n   DEGREE SIGN in a Swiss German layout (Mac:\n   only on ISO keyboards), CIRCUMFLEX ACCENT and\n   DEGREE SIGN in a German layout (Mac: only on\n   ISO keyboards), SUPERSCRIPT TWO and TILDE in a\n   French Windows layout, COMMERCIAL AT and\n   NUMBER SIGN in a French Mac layout on ISO\n   keyboards, and LESS-THAN SIGN and GREATER-THAN\n   SIGN in a Swiss German, German, or French Mac\n   layout on ANSI keyboards."]
    KEY_SCANCODE_GRAVE = 53,
    KEY_SCANCODE_COMMA = 54,
    KEY_SCANCODE_PERIOD = 55,
    KEY_SCANCODE_SLASH = 56,
    KEY_SCANCODE_CAPSLOCK = 57,
    KEY_SCANCODE_F1 = 58,
    KEY_SCANCODE_F2 = 59,
    KEY_SCANCODE_F3 = 60,
    KEY_SCANCODE_F4 = 61,
    KEY_SCANCODE_F5 = 62,
    KEY_SCANCODE_F6 = 63,
    KEY_SCANCODE_F7 = 64,
    KEY_SCANCODE_F8 = 65,
    KEY_SCANCODE_F9 = 66,
    KEY_SCANCODE_F10 = 67,
    KEY_SCANCODE_F11 = 68,
    KEY_SCANCODE_F12 = 69,
    KEY_SCANCODE_PRINTSCREEN = 70,
    KEY_SCANCODE_SCROLLLOCK = 71,
    KEY_SCANCODE_PAUSE = 72,
    #[doc = "< insert on PC, help on some Mac keyboards (but\ndoes send code 73, not 117)"]
    KEY_SCANCODE_INSERT = 73,
    KEY_SCANCODE_HOME = 74,
    KEY_SCANCODE_PAGEUP = 75,
    KEY_SCANCODE_DELETE = 76,
    KEY_SCANCODE_END = 77,
    KEY_SCANCODE_PAGEDOWN = 78,
    KEY_SCANCODE_RIGHT = 79,
    KEY_SCANCODE_LEFT = 80,
    KEY_SCANCODE_DOWN = 81,
    KEY_SCANCODE_UP = 82,
    #[doc = "< num lock on PC, clear on Mac keyboards"]
    KEY_SCANCODE_NUMLOCKCLEAR = 83,
    KEY_SCANCODE_KP_DIVIDE = 84,
    KEY_SCANCODE_KP_MULTIPLY = 85,
    KEY_SCANCODE_KP_MINUS = 86,
    KEY_SCANCODE_KP_PLUS = 87,
    KEY_SCANCODE_KP_ENTER = 88,
    KEY_SCANCODE_KP_1 = 89,
    KEY_SCANCODE_KP_2 = 90,
    KEY_SCANCODE_KP_3 = 91,
    KEY_SCANCODE_KP_4 = 92,
    KEY_SCANCODE_KP_5 = 93,
    KEY_SCANCODE_KP_6 = 94,
    KEY_SCANCODE_KP_7 = 95,
    KEY_SCANCODE_KP_8 = 96,
    KEY_SCANCODE_KP_9 = 97,
    KEY_SCANCODE_KP_0 = 98,
    KEY_SCANCODE_KP_PERIOD = 99,
    #[doc = "< This is the additional key that ISO\n   keyboards have over ANSI ones,\n   located between left shift and Y.\n   Produces GRAVE ACCENT and TILDE in a\n   US or UK Mac layout, REVERSE SOLIDUS\n   (backslash) and VERTICAL LINE in a\n   US or UK Windows layout, and\n   LESS-THAN SIGN and GREATER-THAN SIGN\n   in a Swiss German, German, or French\n   layout."]
    KEY_SCANCODE_NONUSBACKSLASH = 100,
    #[doc = "< windows contextual menu, compose"]
    KEY_SCANCODE_APPLICATION = 101,
    #[doc = "< The USB document says this is a status flag,\n   not a physical key - but some Mac keyboards\n   do have a power key."]
    KEY_SCANCODE_POWER = 102,
    KEY_SCANCODE_KP_EQUALS = 103,
    KEY_SCANCODE_F13 = 104,
    KEY_SCANCODE_F14 = 105,
    KEY_SCANCODE_F15 = 106,
    KEY_SCANCODE_F16 = 107,
    KEY_SCANCODE_F17 = 108,
    KEY_SCANCODE_F18 = 109,
    KEY_SCANCODE_F19 = 110,
    KEY_SCANCODE_F20 = 111,
    KEY_SCANCODE_F21 = 112,
    KEY_SCANCODE_F22 = 113,
    KEY_SCANCODE_F23 = 114,
    KEY_SCANCODE_F24 = 115,
    KEY_SCANCODE_EXECUTE = 116,
    #[doc = "< AL Integrated Help Center"]
    KEY_SCANCODE_HELP = 117,
    #[doc = "< Menu (show menu)"]
    KEY_SCANCODE_MENU = 118,
    KEY_SCANCODE_SELECT = 119,
    #[doc = "< AC Stop"]
    KEY_SCANCODE_STOP = 120,
    #[doc = "< AC Redo/Repeat"]
    KEY_SCANCODE_AGAIN = 121,
    #[doc = "< AC Undo"]
    KEY_SCANCODE_UNDO = 122,
    #[doc = "< AC Cut"]
    KEY_SCANCODE_CUT = 123,
    #[doc = "< AC Copy"]
    KEY_SCANCODE_COPY = 124,
    #[doc = "< AC Paste"]
    KEY_SCANCODE_PASTE = 125,
    #[doc = "< AC Find"]
    KEY_SCANCODE_FIND = 126,
    KEY_SCANCODE_MUTE = 127,
    KEY_SCANCODE_VOLUMEUP = 128,
    KEY_SCANCODE_VOLUMEDOWN = 129,
    KEY_SCANCODE_KP_COMMA = 133,
    KEY_SCANCODE_KP_EQUALSAS400 = 134,
    #[doc = "< used on Asian keyboards, see\nfootnotes in USB doc"]
    KEY_SCANCODE_INTERNATIONAL1 = 135,
    KEY_SCANCODE_INTERNATIONAL2 = 136,
    #[doc = "< Yen"]
    KEY_SCANCODE_INTERNATIONAL3 = 137,
    KEY_SCANCODE_INTERNATIONAL4 = 138,
    KEY_SCANCODE_INTERNATIONAL5 = 139,
    KEY_SCANCODE_INTERNATIONAL6 = 140,
    KEY_SCANCODE_INTERNATIONAL7 = 141,
    KEY_SCANCODE_INTERNATIONAL8 = 142,
    KEY_SCANCODE_INTERNATIONAL9 = 143,
    #[doc = "< Hangul/English toggle"]
    KEY_SCANCODE_LANG1 = 144,
    #[doc = "< Hanja conversion"]
    KEY_SCANCODE_LANG2 = 145,
    #[doc = "< Katakana"]
    KEY_SCANCODE_LANG3 = 146,
    #[doc = "< Hiragana"]
    KEY_SCANCODE_LANG4 = 147,
    #[doc = "< Zenkaku/Hankaku"]
    KEY_SCANCODE_LANG5 = 148,
    #[doc = "< reserved"]
    KEY_SCANCODE_LANG6 = 149,
    #[doc = "< reserved"]
    KEY_SCANCODE_LANG7 = 150,
    #[doc = "< reserved"]
    KEY_SCANCODE_LANG8 = 151,
    #[doc = "< reserved"]
    KEY_SCANCODE_LANG9 = 152,
    #[doc = "< Erase-Eaze"]
    KEY_SCANCODE_ALTERASE = 153,
    KEY_SCANCODE_SYSREQ = 154,
    #[doc = "< AC Cancel"]
    KEY_SCANCODE_CANCEL = 155,
    KEY_SCANCODE_CLEAR = 156,
    KEY_SCANCODE_PRIOR = 157,
    KEY_SCANCODE_RETURN2 = 158,
    KEY_SCANCODE_SEPARATOR = 159,
    KEY_SCANCODE_OUT = 160,
    KEY_SCANCODE_OPER = 161,
    KEY_SCANCODE_CLEARAGAIN = 162,
    KEY_SCANCODE_CRSEL = 163,
    KEY_SCANCODE_EXSEL = 164,
    KEY_SCANCODE_KP_00 = 176,
    KEY_SCANCODE_KP_000 = 177,
    KEY_SCANCODE_THOUSANDSSEPARATOR = 178,
    KEY_SCANCODE_DECIMALSEPARATOR = 179,
    KEY_SCANCODE_CURRENCYUNIT = 180,
    KEY_SCANCODE_CURRENCYSUBUNIT = 181,
    KEY_SCANCODE_KP_LEFTPAREN = 182,
    KEY_SCANCODE_KP_RIGHTPAREN = 183,
    KEY_SCANCODE_KP_LEFTBRACE = 184,
    KEY_SCANCODE_KP_RIGHTBRACE = 185,
    KEY_SCANCODE_KP_TAB = 186,
    KEY_SCANCODE_KP_BACKSPACE = 187,
    KEY_SCANCODE_KP_A = 188,
    KEY_SCANCODE_KP_B = 189,
    KEY_SCANCODE_KP_C = 190,
    KEY_SCANCODE_KP_D = 191,
    KEY_SCANCODE_KP_E = 192,
    KEY_SCANCODE_KP_F = 193,
    KEY_SCANCODE_KP_XOR = 194,
    KEY_SCANCODE_KP_POWER = 195,
    KEY_SCANCODE_KP_PERCENT = 196,
    KEY_SCANCODE_KP_LESS = 197,
    KEY_SCANCODE_KP_GREATER = 198,
    KEY_SCANCODE_KP_AMPERSAND = 199,
    KEY_SCANCODE_KP_DBLAMPERSAND = 200,
    KEY_SCANCODE_KP_VERTICALBAR = 201,
    KEY_SCANCODE_KP_DBLVERTICALBAR = 202,
    KEY_SCANCODE_KP_COLON = 203,
    KEY_SCANCODE_KP_HASH = 204,
    KEY_SCANCODE_KP_SPACE = 205,
    KEY_SCANCODE_KP_AT = 206,
    KEY_SCANCODE_KP_EXCLAM = 207,
    KEY_SCANCODE_KP_MEMSTORE = 208,
    KEY_SCANCODE_KP_MEMRECALL = 209,
    KEY_SCANCODE_KP_MEMCLEAR = 210,
    KEY_SCANCODE_KP_MEMADD = 211,
    KEY_SCANCODE_KP_MEMSUBTRACT = 212,
    KEY_SCANCODE_KP_MEMMULTIPLY = 213,
    KEY_SCANCODE_KP_MEMDIVIDE = 214,
    KEY_SCANCODE_KP_PLUSMINUS = 215,
    KEY_SCANCODE_KP_CLEAR = 216,
    KEY_SCANCODE_KP_CLEARENTRY = 217,
    KEY_SCANCODE_KP_BINARY = 218,
    KEY_SCANCODE_KP_OCTAL = 219,
    KEY_SCANCODE_KP_DECIMAL = 220,
    KEY_SCANCODE_KP_HEXADECIMAL = 221,
    KEY_SCANCODE_LCTRL = 224,
    KEY_SCANCODE_LSHIFT = 225,
    #[doc = "< alt, option"]
    KEY_SCANCODE_LALT = 226,
    #[doc = "< windows, command (apple), meta"]
    KEY_SCANCODE_LGUI = 227,
    KEY_SCANCODE_RCTRL = 228,
    KEY_SCANCODE_RSHIFT = 229,
    #[doc = "< alt gr, option"]
    KEY_SCANCODE_RALT = 230,
    #[doc = "< windows, command (apple), meta"]
    KEY_SCANCODE_RGUI = 231,
    #[doc = "< I'm not sure if this is really not covered\n   by any of the above, but since there's a\n   special KMOD_MODE for it I'm adding it here"]
    KEY_SCANCODE_MODE = 257,
    #[doc = "< Sleep"]
    KEY_SCANCODE_SLEEP = 258,
    #[doc = "< Wake"]
    KEY_SCANCODE_WAKE = 259,
    #[doc = "< Channel Increment"]
    KEY_SCANCODE_CHANNEL_INCREMENT = 260,
    #[doc = "< Channel Decrement"]
    KEY_SCANCODE_CHANNEL_DECREMENT = 261,
    #[doc = "< Play"]
    KEY_SCANCODE_MEDIA_PLAY = 262,
    #[doc = "< Pause"]
    KEY_SCANCODE_MEDIA_PAUSE = 263,
    #[doc = "< Record"]
    KEY_SCANCODE_MEDIA_RECORD = 264,
    #[doc = "< Fast Forward"]
    KEY_SCANCODE_MEDIA_FAST_FORWARD = 265,
    #[doc = "< Rewind"]
    KEY_SCANCODE_MEDIA_REWIND = 266,
    #[doc = "< Next Track"]
    KEY_SCANCODE_MEDIA_NEXT_TRACK = 267,
    #[doc = "< Previous Track"]
    KEY_SCANCODE_MEDIA_PREVIOUS_TRACK = 268,
    #[doc = "< Stop"]
    KEY_SCANCODE_MEDIA_STOP = 269,
    #[doc = "< Eject"]
    KEY_SCANCODE_MEDIA_EJECT = 270,
    #[doc = "< Play / Pause"]
    KEY_SCANCODE_MEDIA_PLAY_PAUSE = 271,
    KEY_SCANCODE_MEDIA_SELECT = 272,
    #[doc = "< AC New"]
    KEY_SCANCODE_AC_NEW = 273,
    #[doc = "< AC Open"]
    KEY_SCANCODE_AC_OPEN = 274,
    #[doc = "< AC Close"]
    KEY_SCANCODE_AC_CLOSE = 275,
    #[doc = "< AC Exit"]
    KEY_SCANCODE_AC_EXIT = 276,
    #[doc = "< AC Save"]
    KEY_SCANCODE_AC_SAVE = 277,
    #[doc = "< AC Print"]
    KEY_SCANCODE_AC_PRINT = 278,
    #[doc = "< AC Properties"]
    KEY_SCANCODE_AC_PROPERTIES = 279,
    #[doc = "< AC Search"]
    KEY_SCANCODE_AC_SEARCH = 280,
    #[doc = "< AC Home"]
    KEY_SCANCODE_AC_HOME = 281,
    #[doc = "< AC Back"]
    KEY_SCANCODE_AC_BACK = 282,
    #[doc = "< AC Forward"]
    KEY_SCANCODE_AC_FORWARD = 283,
    #[doc = "< AC Stop"]
    KEY_SCANCODE_AC_STOP = 284,
    #[doc = "< AC Refresh"]
    KEY_SCANCODE_AC_REFRESH = 285,
    #[doc = "< AC Bookmarks"]
    KEY_SCANCODE_AC_BOOKMARKS = 286,
    #[doc = "< Usually situated below the display on phones and\nused as a multi-function feature key for selecting\na software defined function shown on the bottom left\nof the display."]
    KEY_SCANCODE_SOFTLEFT = 287,
    #[doc = "< Usually situated below the display on phones and\nused as a multi-function feature key for selecting\na software defined function shown on the bottom right\nof the display."]
    KEY_SCANCODE_SOFTRIGHT = 288,
    #[doc = "< Used for accepting phone calls."]
    KEY_SCANCODE_CALL = 289,
    #[doc = "< Used for rejecting phone calls."]
    KEY_SCANCODE_ENDCALL = 290,
    KEY_SCANCODE_FN = 291,
    KEY_SCANCODE_SQUARE = 292,
    KEY_SCANCODE_TRIANGLE = 293,
    KEY_SCANCODE_CROSS = 294,
    KEY_SCANCODE_CIRCLE = 295,
    KEY_SCANCODE_CLOUD = 296,
    KEY_SCANCODE_DIAMOND = 297,
    #[doc = "< 400-500 reserved for dynamic keycodes"]
    KEY_SCANCODE_RESERVED = 400,
    #[doc = "< not a key, just marks the number of scancodes for array bounds"]
    KEY_SCANCODE_COUNT = 512,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum event_type {
    EVENT_NONE = 0,
    EVENT_QUIT = 1,
    EVENT_KEY_DOWN = 2,
    EVENT_KEY_UP = 3,
    EVENT_WINDOW_RESIZE = 4,
}
pub use self::event_type as event_type_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct keyboard_event_t {
    #[doc = "< In nanoseconds, populated using gettimeofday"]
    pub timestamp: u64,
    #[doc = "< SDL physical key code"]
    pub scancode: keyboard_scancode_t,
    #[doc = "< SDL virtual key code"]
    pub key: key_code_t,
    #[doc = "< current key modifiers"]
    pub mod_: key_mod_t,
    #[doc = "< resolved key including mods"]
    pub text: ::core::ffi::c_char,
    #[doc = "< true if the key is pressed"]
    pub down: bool,
    #[doc = "< true if this is a key repeat"]
    pub repeat: bool,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct event_t {
    pub type_: event_type_t,
    pub __bindgen_padding_0: [u8; 4usize],
    pub __bindgen_anon_1: event_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union event_t__bindgen_ty_1 {
    pub keyboard: keyboard_event_t,
}
impl ::core::fmt::Debug for event_t__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "event_t__bindgen_ty_1 {{ union }}")
    }
}
impl ::core::fmt::Debug for event_t {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "event_t {{ type: {:?}, __bindgen_anon_1: {:?} }}",
            self.type_, self.__bindgen_anon_1
        )
    }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum pixel_format_t {
    BADGEVMS_PIXELFORMAT_UNKNOWN = 0,
    BADGEVMS_PIXELFORMAT_INDEX1LSB = 286261504,
    BADGEVMS_PIXELFORMAT_INDEX1MSB = 287310080,
    BADGEVMS_PIXELFORMAT_INDEX2LSB = 470811136,
    BADGEVMS_PIXELFORMAT_INDEX2MSB = 471859712,
    BADGEVMS_PIXELFORMAT_INDEX4LSB = 303039488,
    BADGEVMS_PIXELFORMAT_INDEX4MSB = 304088064,
    BADGEVMS_PIXELFORMAT_INDEX8 = 318769153,
    BADGEVMS_PIXELFORMAT_RGB332 = 336660481,
    BADGEVMS_PIXELFORMAT_XRGB4444 = 353504258,
    BADGEVMS_PIXELFORMAT_XBGR4444 = 357698562,
    BADGEVMS_PIXELFORMAT_XRGB1555 = 353570562,
    BADGEVMS_PIXELFORMAT_XBGR1555 = 357764866,
    BADGEVMS_PIXELFORMAT_ARGB4444 = 355602434,
    BADGEVMS_PIXELFORMAT_RGBA4444 = 356651010,
    BADGEVMS_PIXELFORMAT_ABGR4444 = 359796738,
    BADGEVMS_PIXELFORMAT_BGRA4444 = 360845314,
    BADGEVMS_PIXELFORMAT_ARGB1555 = 355667970,
    BADGEVMS_PIXELFORMAT_RGBA5551 = 356782082,
    BADGEVMS_PIXELFORMAT_ABGR1555 = 359862274,
    BADGEVMS_PIXELFORMAT_BGRA5551 = 360976386,
    BADGEVMS_PIXELFORMAT_RGB565 = 353701890,
    BADGEVMS_PIXELFORMAT_BGR565 = 357896194,
    BADGEVMS_PIXELFORMAT_RGB24 = 386930691,
    BADGEVMS_PIXELFORMAT_BGR24 = 390076419,
    BADGEVMS_PIXELFORMAT_XRGB8888 = 370546692,
    BADGEVMS_PIXELFORMAT_RGBX8888 = 371595268,
    BADGEVMS_PIXELFORMAT_XBGR8888 = 374740996,
    BADGEVMS_PIXELFORMAT_BGRX8888 = 375789572,
    BADGEVMS_PIXELFORMAT_ARGB8888 = 372645892,
    BADGEVMS_PIXELFORMAT_RGBA8888 = 373694468,
    BADGEVMS_PIXELFORMAT_ABGR8888 = 376840196,
    BADGEVMS_PIXELFORMAT_BGRA8888 = 377888772,
    BADGEVMS_PIXELFORMAT_XRGB2101010 = 370614276,
    BADGEVMS_PIXELFORMAT_XBGR2101010 = 374808580,
    BADGEVMS_PIXELFORMAT_ARGB2101010 = 372711428,
    BADGEVMS_PIXELFORMAT_ABGR2101010 = 376905732,
    BADGEVMS_PIXELFORMAT_RGB48 = 403714054,
    BADGEVMS_PIXELFORMAT_BGR48 = 406859782,
    BADGEVMS_PIXELFORMAT_RGBA64 = 404766728,
    BADGEVMS_PIXELFORMAT_ARGB64 = 405815304,
    BADGEVMS_PIXELFORMAT_BGRA64 = 407912456,
    BADGEVMS_PIXELFORMAT_ABGR64 = 408961032,
    BADGEVMS_PIXELFORMAT_RGB48_FLOAT = 437268486,
    BADGEVMS_PIXELFORMAT_BGR48_FLOAT = 440414214,
    BADGEVMS_PIXELFORMAT_RGBA64_FLOAT = 438321160,
    BADGEVMS_PIXELFORMAT_ARGB64_FLOAT = 439369736,
    BADGEVMS_PIXELFORMAT_BGRA64_FLOAT = 441466888,
    BADGEVMS_PIXELFORMAT_ABGR64_FLOAT = 442515464,
    BADGEVMS_PIXELFORMAT_RGB96_FLOAT = 454057996,
    BADGEVMS_PIXELFORMAT_BGR96_FLOAT = 457203724,
    BADGEVMS_PIXELFORMAT_RGBA128_FLOAT = 455114768,
    BADGEVMS_PIXELFORMAT_ARGB128_FLOAT = 456163344,
    BADGEVMS_PIXELFORMAT_BGRA128_FLOAT = 458260496,
    BADGEVMS_PIXELFORMAT_ABGR128_FLOAT = 459309072,
    #[doc = "< Planar mode: Y + V + U  (3 planes)"]
    BADGEVMS_PIXELFORMAT_YV12 = 842094169,
    #[doc = "< Planar mode: Y + U + V  (3 planes)"]
    BADGEVMS_PIXELFORMAT_IYUV = 1448433993,
    #[doc = "< Packed mode: Y0+U0+Y1+V0 (1 plane)"]
    BADGEVMS_PIXELFORMAT_YUY2 = 844715353,
    #[doc = "< Packed mode: U0+Y0+V0+Y1 (1 plane)"]
    BADGEVMS_PIXELFORMAT_UYVY = 1498831189,
    #[doc = "< Packed mode: Y0+V0+Y1+U0 (1 plane)"]
    BADGEVMS_PIXELFORMAT_YVYU = 1431918169,
    #[doc = "< Planar mode: Y + U/V interleaved  (2 planes)"]
    BADGEVMS_PIXELFORMAT_NV12 = 842094158,
    #[doc = "< Planar mode: Y + V/U interleaved  (2 planes)"]
    BADGEVMS_PIXELFORMAT_NV21 = 825382478,
    #[doc = "< Planar mode: Y + U/V interleaved  (2 planes)"]
    BADGEVMS_PIXELFORMAT_P010 = 808530000,
    #[doc = "< Android video texture format"]
    BADGEVMS_PIXELFORMAT_EXTERNAL_OES = 542328143,
    #[doc = "< Motion JPEG"]
    BADGEVMS_PIXELFORMAT_MJPG = 1196444237,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct framebuffer_t {
    pub w: u32,
    pub h: u32,
    pub format: pixel_format_t,
    pub pixels: *mut u16,
}
impl window_flag_t {
    pub const WINDOW_FLAG_NONE: window_flag_t = window_flag_t(0);
    pub const WINDOW_FLAG_FULLSCREEN: window_flag_t = window_flag_t(1);
    pub const WINDOW_FLAG_ALWAYS_ON_TOP: window_flag_t = window_flag_t(2);
    pub const WINDOW_FLAG_UNDECORATED: window_flag_t = window_flag_t(4);
    pub const WINDOW_FLAG_MAXIMIZED: window_flag_t = window_flag_t(8);
    pub const WINDOW_FLAG_MAXIMIZED_LEFT: window_flag_t = window_flag_t(16);
    pub const WINDOW_FLAG_MAXIMIZED_RIGHT: window_flag_t = window_flag_t(32);
    pub const WINDOW_FLAG_DOUBLE_BUFFERED: window_flag_t = window_flag_t(64);
    pub const WINDOW_FLAG_LOW_PRIORITY: window_flag_t = window_flag_t(128);
}
impl ::core::ops::BitOr<window_flag_t> for window_flag_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        window_flag_t(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for window_flag_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: window_flag_t) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<window_flag_t> for window_flag_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        window_flag_t(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for window_flag_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: window_flag_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct window_flag_t(pub ::core::ffi::c_uint);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct window_coords_t {
    pub x: ::core::ffi::c_int,
    pub y: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct window_size_t {
    pub w: ::core::ffi::c_int,
    pub h: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct window_rect_t {
    pub x: ::core::ffi::c_int,
    pub y: ::core::ffi::c_int,
    pub w: ::core::ffi::c_int,
    pub h: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct window {
    _unused: [u8; 0],
}
pub type window_handle_t = *mut window;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DIR {
    pub dd_vfs_idx: u16,
    pub dd_rsv: u16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dirent {
    pub d_ino: ino_t,
    pub d_type: u8,
    pub d_name: [::core::ffi::c_char; 256usize],
    pub __bindgen_padding_0: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stat {
    pub st_dev: dev_t,
    pub st_ino: ino_t,
    pub st_mode: mode_t,
    pub st_nlink: nlink_t,
    pub st_uid: uid_t,
    pub st_gid: gid_t,
    pub st_rdev: dev_t,
    pub st_size: off_t,
    pub __bindgen_padding_0: [u8; 4usize],
    pub st_atim: timespec,
    pub st_mtim: timespec,
    pub st_ctim: timespec,
    pub st_blksize: blksize_t,
    pub st_blocks: blkcnt_t,
    pub st_spare4: [::core::ffi::c_long; 2usize],
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum device_type_t {
    DEVICE_TYPE_BLOCK = 0,
    DEVICE_TYPE_LCD = 1,
    DEVICE_TYPE_KEYBOARD = 2,
    DEVICE_TYPE_BUS = 3,
    DEVICE_TYPE_WIFI = 4,
    DEVICE_TYPE_ORIENTATION = 5,
    DEVICE_TYPE_SOCKET = 6,
    DEVICE_TYPE_FILESYSTEM = 7,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct device {
    pub type_: device_type_t,
    pub _open: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut ::core::ffi::c_void,
            path: *mut path_t,
            flags: ::core::ffi::c_int,
            mode: mode_t,
        ) -> ::core::ffi::c_int,
    >,
    pub _close: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut ::core::ffi::c_void,
            fd: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
    pub _write: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut ::core::ffi::c_void,
            fd: ::core::ffi::c_int,
            buf: *const ::core::ffi::c_void,
            count: size_t,
        ) -> ssize_t,
    >,
    pub _read: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut ::core::ffi::c_void,
            fd: ::core::ffi::c_int,
            buf: *mut ::core::ffi::c_void,
            count: size_t,
        ) -> ssize_t,
    >,
    pub _lseek: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut ::core::ffi::c_void,
            fd: ::core::ffi::c_int,
            offset: off_t,
            whence: ::core::ffi::c_int,
        ) -> ssize_t,
    >,
    pub _destroy: ::core::option::Option<unsafe extern "C" fn(dev: *mut ::core::ffi::c_void)>,
}
pub type device_t = device;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ota_session_t {
    _unused: [u8; 0],
}
pub type ota_handle_t = *mut ota_session_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum wifi_status_t {
    WIFI_DISABLED = 0,
    WIFI_ENABLED = 1,
    WIFI_ASK = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum wifi_connection_status_t {
    WIFI_ERROR = 0,
    WIFI_DISCONNECTED = 1,
    WIFI_CONNECTED = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum wifi_auth_mode_t {
    WIFI_AUTH_NONE = 0,
    WIFI_AUTH_OPEN = 1,
    WIFI_AUTH_WEP = 2,
    WIFI_AUTH_WPA_PSK = 3,
    WIFI_AUTH_WPA2_PSK = 4,
    WIFI_AUTH_WPA_WPA2_PSK = 5,
    WIFI_AUTH_WPA2_ENTERPRISE = 6,
    WIFI_AUTH_WPA3_PSK = 7,
    WIFI_AUTH_WPA2_WPA3_PSK = 8,
    WIFI_AUTH_WAPI_PSK = 9,
    WIFI_AUTH_OWE = 10,
    WIFI_AUTH_WPA3_ENT_192 = 11,
    WIFI_AUTH_DPP = 12,
    WIFI_AUTH_WPA3_ENTERPRISE = 13,
    WIFI_AUTH_WPA2_WPA3_ENTERPRISE = 14,
    WIFI_AUTH_WPA_ENTERPRISE = 15,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wifi_station {
    _unused: [u8; 0],
}
pub type wifi_station_handle = *mut wifi_station;
pub type mac_address_t = [u8; 6usize];
pub type CURL = ::core::ffi::c_void;
pub type CURLcode = ::core::ffi::c_int;
pub type CURLoption = ::core::ffi::c_int;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum curl_easy_info_t {
    CURLINFO_RESPONSE_CODE = 2097154,
    CURLINFO_CONTENT_LENGTH_DOWNLOAD = 3145731,
    CURLINFO_CONTENT_TYPE = 1048594,
    CURLINFO_EFFECTIVE_URL = 1048577,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct curl_slist {
    pub data: *mut ::core::ffi::c_char,
    pub next: *mut curl_slist,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct in_addr {
    pub s_addr: in_addr_t,
}
pub type socklen_t = u32;
pub type sa_family_t = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr {
    pub sa_len: u8,
    pub sa_family: sa_family_t,
    pub sa_data: [::core::ffi::c_char; 14usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct addrinfo {
    pub ai_flags: ::core::ffi::c_int,
    pub ai_family: ::core::ffi::c_int,
    pub ai_socktype: ::core::ffi::c_int,
    pub ai_protocol: ::core::ffi::c_int,
    pub ai_addrlen: socklen_t,
    pub ai_addr: *mut sockaddr,
    pub ai_canonname: *mut ::core::ffi::c_char,
    pub ai_next: *mut addrinfo,
}
#[doc = " Restart output."]
pub type cc_t = u8;
pub type speed_t = u32;
pub type tcflag_t = u16;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct termios {
    pub c_iflag: tcflag_t,
    #[doc = " Input modes"]
    pub c_oflag: tcflag_t,
    #[doc = " Output modes"]
    pub c_cflag: tcflag_t,
    #[doc = " Control modes"]
    pub c_lflag: tcflag_t,
    #[doc = " Local modes"]
    pub c_cc: [cc_t; 11usize],
    pub __bindgen_padding_0: u8,
    #[doc = " Control characters"]
    pub c_ispeed: speed_t,
    #[doc = " input baud rate"]
    pub c_ospeed: speed_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct re_guts {
    pub _address: u8,
}
pub type __builtin_va_list = *mut ::core::ffi::c_void;
